**Hello!**

I'm sorry to hear that you're still experiencing issues with your application. Based on your description, after logging in, you're redirected to the network usage page, but then immediately sent back to the login page. This suggests there's a problem with the authentication flow, particularly with how the client-side code handles authentication.

The main issue lies in the `checkAuthentication()` function in your `main.js` file. Let's go through the problem and provide a solution to fix it.

---

## **Problem Analysis**

### **1. `access_token_cookie` is `HttpOnly`**

- **HttpOnly Cookies:** The `access_token_cookie` is set by the server with the `HttpOnly` flag for security reasons. This means it **cannot be accessed via JavaScript** using `document.cookie`.
- **Implication:** In your `main.js`, the `checkAuthentication()` function attempts to read the `access_token_cookie` using `getCookie('access_token_cookie')`. Since the cookie is `HttpOnly`, this function returns `null` or `undefined`.
- **Result:** The `checkAuthentication()` function believes the user is not authenticated and redirects them to the login page, even though they are logged in.

### **2. Infinite Redirect Loop**

- **After login**, the server correctly sets the `access_token_cookie`.
- **Client-side code** cannot detect the cookie due to the `HttpOnly` flag.
- **The `checkAuthentication()` function** keeps redirecting the user to the login page whenever they access a protected route.

---

## **Solution**

### **Option 1: Remove `checkAuthentication()` Function**

Since the server handles authentication via the `@jwt_required()` decorators, you can safely remove the `checkAuthentication()` function from your `main.js`.

#### **Steps to Implement:**

1. **Remove or Comment Out `checkAuthentication()` and Its Calls**

   **In `main.js`:**

   ```javascript
   // Remove or comment out the checkAuthentication function and its calls
   // function checkAuthentication() {
   //     // Existing code...
   // }

   document.addEventListener('DOMContentLoaded', function() {
       console.log('DOM Content Loaded');
       const path = window.location.pathname;
       const isProtectedPage = ['/devices', '/network_usage'].includes(path);

       if (isProtectedPage) {
           // Remove the call to checkAuthentication()
           // if (checkAuthentication()) {
               initializeSocket();
               if (path === '/devices') {
                   loadDevices();
               } else if (path === '/network_usage') {
                   loadNetworkUsageData();
               }
           // }
       }
   });
   ```

2. **Rely on Server-Side Authentication**

   - The `@jwt_required()` decorators in your Flask routes ensure that only authenticated users can access those endpoints.
   - If a user is not authenticated, the server will return a `401 Unauthorized` response.

3. **Handle Unauthorized Responses in Client-Side Code**

   Modify your `fetchWithAuth` function and other fetch calls to handle `401 Unauthorized` responses.

   **In `main.js`:**

   ```javascript
   function fetchWithAuth(url, options = {}) {
       options.credentials = 'include';

       return fetch(url, options)
           .then(response => {
               if (response.status === 401) {
                   // Redirect to login if unauthorized
                   window.location.href = '/login';
                   throw new Error('Unauthorized');
               }
               return response;
           })
           .catch(error => {
               console.error('Error during fetch:', error);
               throw error;
           });
   }
   ```

   **Example usage in `loadDevices()`:**

   ```javascript
   function loadDevices() {
       const deviceList = document.getElementById('device-list');
       if (!deviceList) return;

       showLoading();
       fetchWithAuth('/api/devices')
           .then(response => response.json())
           .then(devices => {
               refreshDeviceList(devices);
               hideLoading();
           })
           .catch(error => {
               console.error('Error fetching devices:', error);
               if (deviceList) {
                   deviceList.innerHTML = '<tr><td colspan="7">Error loading devices. Please try again.</td></tr>';
               }
               hideLoading();
           });
   }
   ```

### **Option 2: Modify `checkAuthentication()` to Use a Server Endpoint (Less Recommended)**

Alternatively, you can adjust the `checkAuthentication()` function to check authentication status via a server endpoint. However, this adds unnecessary complexity since the server already handles authentication.

---

## **Recommendation**

**Option 1** is the recommended approach. By removing the `checkAuthentication()` function that relies on accessing an `HttpOnly` cookie (which is not possible), you allow the server-side authentication to function as intended.

---

## **Additional Steps**

### **1. Ensure All Fetch Requests Include Credentials**

All fetch requests should include `{ credentials: 'include' }` to send cookies with the requests.

**Example:**

```javascript
fetchWithAuth('/api/devices', { method: 'GET', credentials: 'include' });
```

### **2. Verify Cookie Settings on the Server**

Ensure your Flask app's JWT settings in `app.py` are correct:

```python
app.config["JWT_COOKIE_SECURE"] = False  # False for HTTP, True for HTTPS
app.config['JWT_COOKIE_SAMESITE'] = 'Lax'
```

- **`JWT_COOKIE_SECURE`:** Set to `False` if not using HTTPS.
- **`JWT_COOKIE_SAMESITE`:** Set to `'Lax'` to allow cookies with top-level navigation.

### **3. Check Browser Developer Tools**

- **Inspect Cookies:** Use your browser's developer tools to confirm that the `access_token_cookie` and `refresh_token_cookie` are set after logging in.
- **Verify Network Requests:** Ensure that cookies are being sent with requests to protected endpoints.
- **Console Errors:** Look for any JavaScript errors that might indicate issues.

### **4. Test the Application**

- **Login:** Confirm that you can log in successfully and that you're not redirected back to the login page.
- **Access Protected Pages:** Navigate to `/devices` and `/network_usage` to ensure they load correctly.
- **Logout:** Test the logout functionality to ensure it clears the cookies and redirects appropriately.

---

## **Summary**

- **Problem:** The `checkAuthentication()` function attempts to access an `HttpOnly` cookie, which is not possible, causing it to incorrectly redirect the user back to the login page.
- **Solution:** Remove the `checkAuthentication()` function and rely on server-side authentication via the `@jwt_required()` decorators.
- **Additional Steps:** Ensure fetch requests include credentials, verify cookie settings, and test the application thoroughly.

---

## **Implementing the Changes**

1. **Remove `checkAuthentication()` and Its Calls:**

   ```javascript
   // In main.js
   // Remove or comment out the entire checkAuthentication function and its calls
   ```

2. **Update Event Listener in `main.js`:**

   ```javascript
   document.addEventListener('DOMContentLoaded', function() {
       console.log('DOM Content Loaded');
       const path = window.location.pathname;
       const isProtectedPage = ['/devices', '/network_usage'].includes(path);

       if (isProtectedPage) {
           initializeSocket();
           if (path === '/devices') {
               loadDevices();
           } else if (path === '/network_usage') {
               loadNetworkUsageData();
           }
       }
   });
   ```

3. **Ensure Fetch Requests Include Credentials:**

   ```javascript
   fetchWithAuth('/api/devices', { credentials: 'include' })
   ```

4. **Modify `fetchWithAuth` to Handle Unauthorized Responses:**

   ```javascript
   function fetchWithAuth(url, options = {}) {
       options.credentials = 'include';

       return fetch(url, options)
           .then(response => {
               if (response.status === 401) {
                   window.location.href = '/login';
                   throw new Error('Unauthorized');
               }
               return response;
           })
           .catch(error => {
               console.error('Error during fetch:', error);
               throw error;
           });
   }
   ```

---

## **Conclusion**

By removing the client-side authentication check that relies on an `HttpOnly` cookie and relying on server-side authentication, you should resolve the issue of being redirected back to the login page after logging in.

---

**Please let me know if you have any questions or need further assistance with these changes. I'm here to help you get your application running smoothly!**